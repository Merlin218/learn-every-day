---
title: Docker 是怎么实现的？前端怎么用 Docker 做部署？
day: 4
link: https://mp.weixin.qq.com/s/pc12FDV6AiVt8fbC5tK2Gw
---

<CommonTitle></CommonTitle>

## Docker实现核心原理

### 怎么实现资源的隔离？

linux中提供了`namespace`的机制，可以让进程、用户、网络等分配一个命名空间，在命名空间下的资源都是独立命名。 

namespace 一共有 6 种：
- PID namespace：进程 id 的命名空间，会使命名空间内的这个进程 id 变为 1，而 linux 的初始进程的 id 就是 1，所以这个命名空间内它就是所有进程的父进程了。
- IPC namespace：进程通信的命名空间，能限制只有这个 namespace 内的进程可以相互通信，不能和 namespace 外的进程通信。
- Mount namespace：文件系统挂载的命名空间，会创建一个新的文件系统，namespace 内的文件访问都是在这个文件系统之上。 
- Network namespace：网络的命名空间
- User namespace：用户和用户组的命名空间
- UTS namespace：主机名和域名的命名空间

### 怎么能限制容器的资源访问呢

linux 操作系统的另一种机制：Control Group。

创建一个 Control Group 可以给它指定参数，比如 cpu 用多少、内存用多少、磁盘用多少，然后加到这个组里的进程就会受到这个限制。

这样，创建容器的时候先创建一个 Control Group，指定资源的限制，然后把容器进程加到这个 Control Group 里，就不会有容器占用过多资源的问题了。

### 怎么避免磁盘空间的浪费？

每个容器都是独立的文件系统，相互独立，而这些文件系统之间可能很大部分都是一样的，同样的内容占据了很大的磁盘空间，会导致浪费。

Docker 设计了一种分层机制：每一层都是不可修改的，也叫做镜像。要修改会创建一个新的层，在这一层做修改。

然后通过一种叫做 `UnionFS` 的机制把这些层合并起来，变成一个文件系统。

Docker 通过这种分层的镜像存储，写时复制的机制，极大的减少了文件系统的磁盘占用。而且这种镜像是可以复用的，上传到镜像仓库，别人拉下来也可以直接用。

## 前端部署最佳实践

Docker 是分层存储的，修改的时候会创建一个新的层，所以这里的每一行都会创建一个新的层。

这些指令的含义如下：
- FROM：基于一个基础镜像来修改
- WORKDIR：指定当前工作目录
- COPY：把容器外的内容复制到容器内
- EXPOSE：声明当前容器要访问的网络端口，比如这里起服务会用到 8080
- RUN：在容器内执行命令
- CMD：容器启动的时候执行的命令

### 分离`构建镜像`和`运行镜像`过程

我们把两个镜像的生成过程写到了一个 dockerfile 里，这是 docker 支持的多阶段构建。

第一个 FROM 里我们写了 as build_image，这是把第一个镜像命名为 build_image。

后面第二个镜像 COPY 的时候就可以指定 --from=build_image 来从那个镜像复制内容了。

这样，最终只会留下第二个镜像，这个镜像里只有生产环境需要的依赖，体积更小。传输速度、运行速度也会更快。
